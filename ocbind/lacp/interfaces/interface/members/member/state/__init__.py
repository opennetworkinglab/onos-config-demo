# -*- coding: utf-8 -*-
from operator import attrgetter
import pyangbind.lib.xpathhelper as xpathhelper
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

from . import counters
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lacp - based on the path /lacp/interfaces/interface/members/member/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for aggregate members
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__activity','__timeout','__synchronization','__aggregatable','__collecting','__distributing','__system_id','__oper_key','__partner_id','__partner_key','__port_num','__partner_port_num','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)
    self.__activity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)
    self.__synchronization = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)
    self.__aggregatable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__collecting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__distributing = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__system_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    self.__oper_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__partner_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    self.__partner_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__partner_port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['lacp', 'interfaces', 'interface', 'members', 'member', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /lacp/interfaces/interface/members/member/state/interface (oc-if:base-interface-ref)

    YANG Description: Reference to interface member of the LACP aggregate
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /lacp/interfaces/interface/members/member/state/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to interface member of the LACP aggregate
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)


  def _get_activity(self):
    """
    Getter method for activity, mapped from YANG variable /lacp/interfaces/interface/members/member/state/activity (lacp-activity-type)

    YANG Description: Indicates participant is active or passive
    """
    return self.__activity
      
  def _set_activity(self, v, load=False):
    """
    Setter method for activity, mapped from YANG variable /lacp/interfaces/interface/members/member/state/activity (lacp-activity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_activity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_activity() directly.

    YANG Description: Indicates participant is active or passive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """activity must be of a type compatible with lacp-activity-type""",
          'defined-type': "openconfig-lacp:lacp-activity-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)""",
        })

    self.__activity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_activity(self):
    self.__activity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /lacp/interfaces/interface/members/member/state/timeout (lacp-timeout-type)

    YANG Description: The timeout type (short or long) used by the
participant
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /lacp/interfaces/interface/members/member/state/timeout (lacp-timeout-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: The timeout type (short or long) used by the
participant
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with lacp-timeout-type""",
          'defined-type': "openconfig-lacp:lacp-timeout-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)


  def _get_synchronization(self):
    """
    Getter method for synchronization, mapped from YANG variable /lacp/interfaces/interface/members/member/state/synchronization (lacp-synchronization-type)

    YANG Description: Indicates whether the participant is in-sync or
out-of-sync
    """
    return self.__synchronization
      
  def _set_synchronization(self, v, load=False):
    """
    Setter method for synchronization, mapped from YANG variable /lacp/interfaces/interface/members/member/state/synchronization (lacp-synchronization-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_synchronization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_synchronization() directly.

    YANG Description: Indicates whether the participant is in-sync or
out-of-sync
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """synchronization must be of a type compatible with lacp-synchronization-type""",
          'defined-type': "openconfig-lacp:lacp-synchronization-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)""",
        })

    self.__synchronization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_synchronization(self):
    self.__synchronization = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)


  def _get_aggregatable(self):
    """
    Getter method for aggregatable, mapped from YANG variable /lacp/interfaces/interface/members/member/state/aggregatable (boolean)

    YANG Description: A true value indicates that the participant will allow
the link to be used as part of the aggregate. A false
value indicates the link should be used as an individual
link
    """
    return self.__aggregatable
      
  def _set_aggregatable(self, v, load=False):
    """
    Setter method for aggregatable, mapped from YANG variable /lacp/interfaces/interface/members/member/state/aggregatable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregatable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregatable() directly.

    YANG Description: A true value indicates that the participant will allow
the link to be used as part of the aggregate. A false
value indicates the link should be used as an individual
link
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregatable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__aggregatable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregatable(self):
    self.__aggregatable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_collecting(self):
    """
    Getter method for collecting, mapped from YANG variable /lacp/interfaces/interface/members/member/state/collecting (boolean)

    YANG Description: If true, the participant is collecting incoming frames
on the link, otherwise false
    """
    return self.__collecting
      
  def _set_collecting(self, v, load=False):
    """
    Setter method for collecting, mapped from YANG variable /lacp/interfaces/interface/members/member/state/collecting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collecting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collecting() directly.

    YANG Description: If true, the participant is collecting incoming frames
on the link, otherwise false
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """collecting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__collecting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_collecting(self):
    self.__collecting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_distributing(self):
    """
    Getter method for distributing, mapped from YANG variable /lacp/interfaces/interface/members/member/state/distributing (boolean)

    YANG Description: When true, the participant is distributing outgoing
frames; when false, distribution is disabled
    """
    return self.__distributing
      
  def _set_distributing(self, v, load=False):
    """
    Setter method for distributing, mapped from YANG variable /lacp/interfaces/interface/members/member/state/distributing (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distributing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distributing() directly.

    YANG Description: When true, the participant is distributing outgoing
frames; when false, distribution is disabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distributing must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__distributing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distributing(self):
    self.__distributing = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_system_id(self):
    """
    Getter method for system_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/system_id (oc-yang:mac-address)

    YANG Description: MAC address that defines the local system ID for the
aggregate interface
    """
    return self.__system_id
      
  def _set_system_id(self, v, load=False):
    """
    Setter method for system_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/system_id (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_id() directly.

    YANG Description: MAC address that defines the local system ID for the
aggregate interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_id must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__system_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_id(self):
    self.__system_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)


  def _get_oper_key(self):
    """
    Getter method for oper_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/oper_key (uint16)

    YANG Description: Current operational value of the key for the aggregate
interface
    """
    return self.__oper_key
      
  def _set_oper_key(self, v, load=False):
    """
    Setter method for oper_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/oper_key (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_key() directly.

    YANG Description: Current operational value of the key for the aggregate
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_key must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__oper_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_key(self):
    self.__oper_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_partner_id(self):
    """
    Getter method for partner_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_id (oc-yang:mac-address)

    YANG Description: MAC address representing the protocol partner's interface
system ID
    """
    return self.__partner_id
      
  def _set_partner_id(self, v, load=False):
    """
    Setter method for partner_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_id (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_id() directly.

    YANG Description: MAC address representing the protocol partner's interface
system ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_id must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__partner_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_id(self):
    self.__partner_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)


  def _get_partner_key(self):
    """
    Getter method for partner_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_key (uint16)

    YANG Description: Operational value of the protocol partner's key
    """
    return self.__partner_key
      
  def _set_partner_key(self, v, load=False):
    """
    Setter method for partner_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_key (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_key() directly.

    YANG Description: Operational value of the protocol partner's key
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_key must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__partner_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_key(self):
    self.__partner_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_port_num(self):
    """
    Getter method for port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/port_num (uint16)

    YANG Description: Port number of the local (actor) aggregation member
    """
    return self.__port_num
      
  def _set_port_num(self, v, load=False):
    """
    Setter method for port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/port_num (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_num() directly.

    YANG Description: Port number of the local (actor) aggregation member
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_num must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__port_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_num(self):
    self.__port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_partner_port_num(self):
    """
    Getter method for partner_port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_port_num (uint16)

    YANG Description: Port number of the partner (remote) port for this member
port
    """
    return self.__partner_port_num
      
  def _set_partner_port_num(self, v, load=False):
    """
    Setter method for partner_port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_port_num (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_port_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_port_num() directly.

    YANG Description: Port number of the partner (remote) port for this member
port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_port_num must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__partner_port_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_port_num(self):
    self.__partner_port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /lacp/interfaces/interface/members/member/state/counters (container)

    YANG Description: LACP protocol counters
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /lacp/interfaces/interface/members/member/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: LACP protocol counters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)

  interface = __builtin__.property(_get_interface)
  activity = __builtin__.property(_get_activity)
  timeout = __builtin__.property(_get_timeout)
  synchronization = __builtin__.property(_get_synchronization)
  aggregatable = __builtin__.property(_get_aggregatable)
  collecting = __builtin__.property(_get_collecting)
  distributing = __builtin__.property(_get_distributing)
  system_id = __builtin__.property(_get_system_id)
  oper_key = __builtin__.property(_get_oper_key)
  partner_id = __builtin__.property(_get_partner_id)
  partner_key = __builtin__.property(_get_partner_key)
  port_num = __builtin__.property(_get_port_num)
  partner_port_num = __builtin__.property(_get_partner_port_num)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('interface', interface), ('activity', activity), ('timeout', timeout), ('synchronization', synchronization), ('aggregatable', aggregatable), ('collecting', collecting), ('distributing', distributing), ('system_id', system_id), ('oper_key', oper_key), ('partner_id', partner_id), ('partner_key', partner_key), ('port_num', port_num), ('partner_port_num', partner_port_num), ('counters', counters), ])


from . import counters
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lacp - based on the path /lacp/interfaces/interface/members/member/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for aggregate members
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__activity','__timeout','__synchronization','__aggregatable','__collecting','__distributing','__system_id','__oper_key','__partner_id','__partner_key','__port_num','__partner_port_num','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)
    self.__activity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)
    self.__synchronization = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)
    self.__aggregatable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__collecting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__distributing = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__system_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    self.__oper_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__partner_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    self.__partner_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__partner_port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['lacp', 'interfaces', 'interface', 'members', 'member', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /lacp/interfaces/interface/members/member/state/interface (oc-if:base-interface-ref)

    YANG Description: Reference to interface member of the LACP aggregate
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /lacp/interfaces/interface/members/member/state/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to interface member of the LACP aggregate
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)


  def _get_activity(self):
    """
    Getter method for activity, mapped from YANG variable /lacp/interfaces/interface/members/member/state/activity (lacp-activity-type)

    YANG Description: Indicates participant is active or passive
    """
    return self.__activity
      
  def _set_activity(self, v, load=False):
    """
    Setter method for activity, mapped from YANG variable /lacp/interfaces/interface/members/member/state/activity (lacp-activity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_activity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_activity() directly.

    YANG Description: Indicates participant is active or passive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """activity must be of a type compatible with lacp-activity-type""",
          'defined-type': "openconfig-lacp:lacp-activity-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)""",
        })

    self.__activity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_activity(self):
    self.__activity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /lacp/interfaces/interface/members/member/state/timeout (lacp-timeout-type)

    YANG Description: The timeout type (short or long) used by the
participant
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /lacp/interfaces/interface/members/member/state/timeout (lacp-timeout-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: The timeout type (short or long) used by the
participant
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with lacp-timeout-type""",
          'defined-type': "openconfig-lacp:lacp-timeout-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)


  def _get_synchronization(self):
    """
    Getter method for synchronization, mapped from YANG variable /lacp/interfaces/interface/members/member/state/synchronization (lacp-synchronization-type)

    YANG Description: Indicates whether the participant is in-sync or
out-of-sync
    """
    return self.__synchronization
      
  def _set_synchronization(self, v, load=False):
    """
    Setter method for synchronization, mapped from YANG variable /lacp/interfaces/interface/members/member/state/synchronization (lacp-synchronization-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_synchronization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_synchronization() directly.

    YANG Description: Indicates whether the participant is in-sync or
out-of-sync
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """synchronization must be of a type compatible with lacp-synchronization-type""",
          'defined-type': "openconfig-lacp:lacp-synchronization-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)""",
        })

    self.__synchronization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_synchronization(self):
    self.__synchronization = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)


  def _get_aggregatable(self):
    """
    Getter method for aggregatable, mapped from YANG variable /lacp/interfaces/interface/members/member/state/aggregatable (boolean)

    YANG Description: A true value indicates that the participant will allow
the link to be used as part of the aggregate. A false
value indicates the link should be used as an individual
link
    """
    return self.__aggregatable
      
  def _set_aggregatable(self, v, load=False):
    """
    Setter method for aggregatable, mapped from YANG variable /lacp/interfaces/interface/members/member/state/aggregatable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregatable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregatable() directly.

    YANG Description: A true value indicates that the participant will allow
the link to be used as part of the aggregate. A false
value indicates the link should be used as an individual
link
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregatable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__aggregatable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregatable(self):
    self.__aggregatable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_collecting(self):
    """
    Getter method for collecting, mapped from YANG variable /lacp/interfaces/interface/members/member/state/collecting (boolean)

    YANG Description: If true, the participant is collecting incoming frames
on the link, otherwise false
    """
    return self.__collecting
      
  def _set_collecting(self, v, load=False):
    """
    Setter method for collecting, mapped from YANG variable /lacp/interfaces/interface/members/member/state/collecting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collecting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collecting() directly.

    YANG Description: If true, the participant is collecting incoming frames
on the link, otherwise false
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """collecting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__collecting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_collecting(self):
    self.__collecting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_distributing(self):
    """
    Getter method for distributing, mapped from YANG variable /lacp/interfaces/interface/members/member/state/distributing (boolean)

    YANG Description: When true, the participant is distributing outgoing
frames; when false, distribution is disabled
    """
    return self.__distributing
      
  def _set_distributing(self, v, load=False):
    """
    Setter method for distributing, mapped from YANG variable /lacp/interfaces/interface/members/member/state/distributing (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distributing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distributing() directly.

    YANG Description: When true, the participant is distributing outgoing
frames; when false, distribution is disabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distributing must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__distributing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distributing(self):
    self.__distributing = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_system_id(self):
    """
    Getter method for system_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/system_id (oc-yang:mac-address)

    YANG Description: MAC address that defines the local system ID for the
aggregate interface
    """
    return self.__system_id
      
  def _set_system_id(self, v, load=False):
    """
    Setter method for system_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/system_id (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_id() directly.

    YANG Description: MAC address that defines the local system ID for the
aggregate interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_id must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__system_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_id(self):
    self.__system_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)


  def _get_oper_key(self):
    """
    Getter method for oper_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/oper_key (uint16)

    YANG Description: Current operational value of the key for the aggregate
interface
    """
    return self.__oper_key
      
  def _set_oper_key(self, v, load=False):
    """
    Setter method for oper_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/oper_key (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_key() directly.

    YANG Description: Current operational value of the key for the aggregate
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_key must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__oper_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_key(self):
    self.__oper_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_partner_id(self):
    """
    Getter method for partner_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_id (oc-yang:mac-address)

    YANG Description: MAC address representing the protocol partner's interface
system ID
    """
    return self.__partner_id
      
  def _set_partner_id(self, v, load=False):
    """
    Setter method for partner_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_id (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_id() directly.

    YANG Description: MAC address representing the protocol partner's interface
system ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_id must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__partner_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_id(self):
    self.__partner_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)


  def _get_partner_key(self):
    """
    Getter method for partner_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_key (uint16)

    YANG Description: Operational value of the protocol partner's key
    """
    return self.__partner_key
      
  def _set_partner_key(self, v, load=False):
    """
    Setter method for partner_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_key (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_key() directly.

    YANG Description: Operational value of the protocol partner's key
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_key must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__partner_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_key(self):
    self.__partner_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_port_num(self):
    """
    Getter method for port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/port_num (uint16)

    YANG Description: Port number of the local (actor) aggregation member
    """
    return self.__port_num
      
  def _set_port_num(self, v, load=False):
    """
    Setter method for port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/port_num (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_num() directly.

    YANG Description: Port number of the local (actor) aggregation member
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_num must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__port_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_num(self):
    self.__port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_partner_port_num(self):
    """
    Getter method for partner_port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_port_num (uint16)

    YANG Description: Port number of the partner (remote) port for this member
port
    """
    return self.__partner_port_num
      
  def _set_partner_port_num(self, v, load=False):
    """
    Setter method for partner_port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_port_num (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_port_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_port_num() directly.

    YANG Description: Port number of the partner (remote) port for this member
port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_port_num must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__partner_port_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_port_num(self):
    self.__partner_port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /lacp/interfaces/interface/members/member/state/counters (container)

    YANG Description: LACP protocol counters
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /lacp/interfaces/interface/members/member/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: LACP protocol counters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)

  interface = __builtin__.property(_get_interface)
  activity = __builtin__.property(_get_activity)
  timeout = __builtin__.property(_get_timeout)
  synchronization = __builtin__.property(_get_synchronization)
  aggregatable = __builtin__.property(_get_aggregatable)
  collecting = __builtin__.property(_get_collecting)
  distributing = __builtin__.property(_get_distributing)
  system_id = __builtin__.property(_get_system_id)
  oper_key = __builtin__.property(_get_oper_key)
  partner_id = __builtin__.property(_get_partner_id)
  partner_key = __builtin__.property(_get_partner_key)
  port_num = __builtin__.property(_get_port_num)
  partner_port_num = __builtin__.property(_get_partner_port_num)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('interface', interface), ('activity', activity), ('timeout', timeout), ('synchronization', synchronization), ('aggregatable', aggregatable), ('collecting', collecting), ('distributing', distributing), ('system_id', system_id), ('oper_key', oper_key), ('partner_id', partner_id), ('partner_key', partner_key), ('port_num', port_num), ('partner_port_num', partner_port_num), ('counters', counters), ])


from . import counters
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lacp - based on the path /lacp/interfaces/interface/members/member/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for aggregate members
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__activity','__timeout','__synchronization','__aggregatable','__collecting','__distributing','__system_id','__oper_key','__partner_id','__partner_key','__port_num','__partner_port_num','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    helper = kwargs.pop("path_helper", None)
    if helper is False:
      self._path_helper = False
    elif helper is not None and isinstance(helper, xpathhelper.YANGPathHelper):
      self._path_helper = helper
    elif hasattr(self, "_parent"):
      helper = getattr(self._parent, "_path_helper", False)
      self._path_helper = helper
    else:
      self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)
    self.__activity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)
    self.__synchronization = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)
    self.__aggregatable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__collecting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__distributing = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    self.__system_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    self.__oper_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__partner_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    self.__partner_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__partner_port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['lacp', 'interfaces', 'interface', 'members', 'member', 'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /lacp/interfaces/interface/members/member/state/interface (oc-if:base-interface-ref)

    YANG Description: Reference to interface member of the LACP aggregate
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /lacp/interfaces/interface/members/member/state/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to interface member of the LACP aggregate
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=ReferenceType(referenced_path='/oc-if:interfaces/oc-if:interface/oc-if:name', caller=self._path() + ['interface'], path_helper=self._path_helper, require_instance=True), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-if:base-interface-ref', is_config=False)


  def _get_activity(self):
    """
    Getter method for activity, mapped from YANG variable /lacp/interfaces/interface/members/member/state/activity (lacp-activity-type)

    YANG Description: Indicates participant is active or passive
    """
    return self.__activity
      
  def _set_activity(self, v, load=False):
    """
    Setter method for activity, mapped from YANG variable /lacp/interfaces/interface/members/member/state/activity (lacp-activity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_activity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_activity() directly.

    YANG Description: Indicates participant is active or passive
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """activity must be of a type compatible with lacp-activity-type""",
          'defined-type': "openconfig-lacp:lacp-activity-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)""",
        })

    self.__activity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_activity(self):
    self.__activity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE': {}, 'PASSIVE': {}},), is_leaf=True, yang_name="activity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-activity-type', is_config=False)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /lacp/interfaces/interface/members/member/state/timeout (lacp-timeout-type)

    YANG Description: The timeout type (short or long) used by the
participant
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /lacp/interfaces/interface/members/member/state/timeout (lacp-timeout-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: The timeout type (short or long) used by the
participant
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with lacp-timeout-type""",
          'defined-type': "openconfig-lacp:lacp-timeout-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LONG': {}, 'SHORT': {}},), is_leaf=True, yang_name="timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-timeout-type', is_config=False)


  def _get_synchronization(self):
    """
    Getter method for synchronization, mapped from YANG variable /lacp/interfaces/interface/members/member/state/synchronization (lacp-synchronization-type)

    YANG Description: Indicates whether the participant is in-sync or
out-of-sync
    """
    return self.__synchronization
      
  def _set_synchronization(self, v, load=False):
    """
    Setter method for synchronization, mapped from YANG variable /lacp/interfaces/interface/members/member/state/synchronization (lacp-synchronization-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_synchronization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_synchronization() directly.

    YANG Description: Indicates whether the participant is in-sync or
out-of-sync
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """synchronization must be of a type compatible with lacp-synchronization-type""",
          'defined-type': "openconfig-lacp:lacp-synchronization-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)""",
        })

    self.__synchronization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_synchronization(self):
    self.__synchronization = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IN_SYNC': {}, 'OUT_SYNC': {}},), is_leaf=True, yang_name="synchronization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='lacp-synchronization-type', is_config=False)


  def _get_aggregatable(self):
    """
    Getter method for aggregatable, mapped from YANG variable /lacp/interfaces/interface/members/member/state/aggregatable (boolean)

    YANG Description: A true value indicates that the participant will allow
the link to be used as part of the aggregate. A false
value indicates the link should be used as an individual
link
    """
    return self.__aggregatable
      
  def _set_aggregatable(self, v, load=False):
    """
    Setter method for aggregatable, mapped from YANG variable /lacp/interfaces/interface/members/member/state/aggregatable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregatable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregatable() directly.

    YANG Description: A true value indicates that the participant will allow
the link to be used as part of the aggregate. A false
value indicates the link should be used as an individual
link
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregatable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__aggregatable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregatable(self):
    self.__aggregatable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="aggregatable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_collecting(self):
    """
    Getter method for collecting, mapped from YANG variable /lacp/interfaces/interface/members/member/state/collecting (boolean)

    YANG Description: If true, the participant is collecting incoming frames
on the link, otherwise false
    """
    return self.__collecting
      
  def _set_collecting(self, v, load=False):
    """
    Setter method for collecting, mapped from YANG variable /lacp/interfaces/interface/members/member/state/collecting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collecting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collecting() directly.

    YANG Description: If true, the participant is collecting incoming frames
on the link, otherwise false
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """collecting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__collecting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_collecting(self):
    self.__collecting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="collecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_distributing(self):
    """
    Getter method for distributing, mapped from YANG variable /lacp/interfaces/interface/members/member/state/distributing (boolean)

    YANG Description: When true, the participant is distributing outgoing
frames; when false, distribution is disabled
    """
    return self.__distributing
      
  def _set_distributing(self, v, load=False):
    """
    Setter method for distributing, mapped from YANG variable /lacp/interfaces/interface/members/member/state/distributing (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distributing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distributing() directly.

    YANG Description: When true, the participant is distributing outgoing
frames; when false, distribution is disabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distributing must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)""",
        })

    self.__distributing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distributing(self):
    self.__distributing = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="distributing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='boolean', is_config=False)


  def _get_system_id(self):
    """
    Getter method for system_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/system_id (oc-yang:mac-address)

    YANG Description: MAC address that defines the local system ID for the
aggregate interface
    """
    return self.__system_id
      
  def _set_system_id(self, v, load=False):
    """
    Setter method for system_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/system_id (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_id() directly.

    YANG Description: MAC address that defines the local system ID for the
aggregate interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_id must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__system_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_id(self):
    self.__system_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="system-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)


  def _get_oper_key(self):
    """
    Getter method for oper_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/oper_key (uint16)

    YANG Description: Current operational value of the key for the aggregate
interface
    """
    return self.__oper_key
      
  def _set_oper_key(self, v, load=False):
    """
    Setter method for oper_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/oper_key (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_key() directly.

    YANG Description: Current operational value of the key for the aggregate
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_key must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__oper_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_key(self):
    self.__oper_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="oper-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_partner_id(self):
    """
    Getter method for partner_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_id (oc-yang:mac-address)

    YANG Description: MAC address representing the protocol partner's interface
system ID
    """
    return self.__partner_id
      
  def _set_partner_id(self, v, load=False):
    """
    Setter method for partner_id, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_id (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_id() directly.

    YANG Description: MAC address representing the protocol partner's interface
system ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_id must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__partner_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_id(self):
    self.__partner_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="partner-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='oc-yang:mac-address', is_config=False)


  def _get_partner_key(self):
    """
    Getter method for partner_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_key (uint16)

    YANG Description: Operational value of the protocol partner's key
    """
    return self.__partner_key
      
  def _set_partner_key(self, v, load=False):
    """
    Setter method for partner_key, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_key (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_key() directly.

    YANG Description: Operational value of the protocol partner's key
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_key must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__partner_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_key(self):
    self.__partner_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_port_num(self):
    """
    Getter method for port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/port_num (uint16)

    YANG Description: Port number of the local (actor) aggregation member
    """
    return self.__port_num
      
  def _set_port_num(self, v, load=False):
    """
    Setter method for port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/port_num (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_num() directly.

    YANG Description: Port number of the local (actor) aggregation member
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_num must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__port_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_num(self):
    self.__port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_partner_port_num(self):
    """
    Getter method for partner_port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_port_num (uint16)

    YANG Description: Port number of the partner (remote) port for this member
port
    """
    return self.__partner_port_num
      
  def _set_partner_port_num(self, v, load=False):
    """
    Setter method for partner_port_num, mapped from YANG variable /lacp/interfaces/interface/members/member/state/partner_port_num (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partner_port_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partner_port_num() directly.

    YANG Description: Port number of the partner (remote) port for this member
port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partner_port_num must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)""",
        })

    self.__partner_port_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partner_port_num(self):
    self.__partner_port_num = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="partner-port-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='uint16', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /lacp/interfaces/interface/members/member/state/counters (container)

    YANG Description: LACP protocol counters
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /lacp/interfaces/interface/members/member/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: LACP protocol counters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=False)

  interface = __builtin__.property(_get_interface)
  activity = __builtin__.property(_get_activity)
  timeout = __builtin__.property(_get_timeout)
  synchronization = __builtin__.property(_get_synchronization)
  aggregatable = __builtin__.property(_get_aggregatable)
  collecting = __builtin__.property(_get_collecting)
  distributing = __builtin__.property(_get_distributing)
  system_id = __builtin__.property(_get_system_id)
  oper_key = __builtin__.property(_get_oper_key)
  partner_id = __builtin__.property(_get_partner_id)
  partner_key = __builtin__.property(_get_partner_key)
  port_num = __builtin__.property(_get_port_num)
  partner_port_num = __builtin__.property(_get_partner_port_num)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('interface', interface), ('activity', activity), ('timeout', timeout), ('synchronization', synchronization), ('aggregatable', aggregatable), ('collecting', collecting), ('distributing', distributing), ('system_id', system_id), ('oper_key', oper_key), ('partner_id', partner_id), ('partner_key', partner_key), ('port_num', port_num), ('partner_port_num', partner_port_num), ('counters', counters), ])


